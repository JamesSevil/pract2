# Теорема Ферма и св-во сравнений(1 алгоритм)
def CheckPrime(p): # проверка, является ли модуль простым числом
    
    if (p <= 1): return False # не может быть <=1
    for i in range(2, int(p ** 0.5) + 1): # начинаем с 2 до (квадратного корня из числа) <=p
        if (p % i == 0): return False # Если нет остатка, то не простое, иначе простое
        
    return True

def algorithm(a, x, p): # Алгоритм нахождения остатка
    
    nums = [0] * 100 # инициализируем массив чисел, в котором хранятся уникальные остатки
    
    nums[0] = a % p # присваиваем 1 числу остаток
    k = 0 # условие выхода
    n = 1 # счётчик
    i = 1
    while k == 0:
        nums[i] = pow(a, i+1)
        nums[i] = nums[i] % p
        if nums[i] == nums[0]: k += 1 # если найденные остаток = первому, то выходим из цикла
        else: n += 1 # иначе увеличиваем счётчик
        i += 1

    result = 0
    num = x % n # считаем, сколько полных циклов входит в степень
    if num == 0: result = nums[n-1] # если остаток 0, то результат = последнему уникальному остатку
    else: result = nums[num-1] # иначе результат = своему номеру уникального остатка

    return result

def algorithm2(a, x, p):
    
    nums = [0] * 100 # инициализируем массив чисел, в котром хранится числовой ряд a
    stepen = 1 # для проверки, чтобы степень не превышала себя
    nums[0] = a % p # присваиваем 1 элементу значение 1 степени
    k = 0 # условие выхода
    i = 1 # счётчик
    while (k == 0):
        stepen = stepen * 2 # возводим степень в квадрат
        if stepen <= x:
            nums[i] = (nums[i-1] * nums[i-1]) % p # Если степень не превышает степень в числе, то считаем
            i = i + 1 # счётчик +1
        else:
            k = k + 1 # иначе выход из цикла
    
    binary = [0] * 100 # инициализируем массив чисел, в котором хранится число в двоичной степени
    k = 0 # условие выхода
    i = 0 # счётчик
    while k == 0:
        binary[i] = x % 2 # считаем первый множитель в формуле
        x = x // 2
        if x == 1:
            k = k + 1
            binary[i+1] = x
        i = i + 1
    
    result = 1
    for j in range(i+1):
        result = result * pow(nums[j], binary[j]) # перемножаем множители между собой
    
    result = result % p # получаем остаток, деля число из формулы на модуль
    
    return result


print("Нахождение остатка числа a^x mod p:")

a = int(input("Введите число а: ")) # ввод чисел
x = int(input("Введите степень x: "))
p = int(input("Введите модуль p: "))

if (CheckPrime(p) == False): print("p не простое число.") # проверка, является ли модуль простым числом
elif (a % p == 0) and (x != 0): print("Теорема Ферма не выполняется: a^x ≡ 0 (mod p)") # проверка, выполняется ли теорема Ферма
else: # вывод результата
    result1 = algorithm(a, x, p)
    print(f"Алгоритм 1: {a}^{x} mod {p} = {result1}")
    result2 = algorithm(a, x, p)
    print(f"Алгоритм 2: {a}^{x} mod {p} = {result2}")