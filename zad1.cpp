// Теорема Ферма и св-во сравнений(1 алгоритм)
#include <iostream>
#include <math.h>

using namespace std;

bool CheckPrime(int p) { // проверка, является ли модуль простым числом
    
    if (p <= 1) return false; // не может быть <=1
    for (int i = 2; i * i <= p; ++i) { // начинаем с 2 до (квадратного корня из числа) <=p
        if (p % i == 0) return false; // Если нет остатка, то не простое, иначе простое
    }

    return true;
}

int algorithm1(int a, int x, int p) { // Алгоритм нахождения остатка

    int nums[100]; // инициализируем массив чисел, в котором хранятся уникальные остатки

    nums[0] = a % p; // присваиваем 1 числу остаток
    int k=0, n=1; // k - условие выхода | n - счётчик уникальных остатков
    for (int i=1; k==0; i++) {
        nums[i] = pow(a, i+1);
        nums[i] = nums[i] % p;
        if (nums[i] == nums[0]) { 
            k = k + 1; // если найденный остаток = первому, то выходим из цикла
        } else {
            n = n + 1; // иначе увеличиваем счётчик
        }
    }

    int result;
    int num = x % n; // считаем, сколько полных циклов входит в степень
    if (num == 0) { 
        result = nums[n-1]; // если остаток 0, то результат = последнему уникальному остатку
    } else {
        result = nums[num-1]; // иначе результат = своему номеру уникального остатка
    }

    return result;
}

int algorithm2(int a, int x, int p) {

    int nums[100]; // инициализируем массив чисел, в котром хранится числовой ряд a

    int stepen = 1; // для проверки, чтобы степень не превышала себя
    nums[0] = a % p; // присваиваем 1 элементу значение 1 степени
    int k=0; // условие выхода
    int i=1; // счётчик
    while(k == 0) {
        stepen = stepen * 2; // возводим степень в квадрат
        if (stepen <= x) {
            nums[i] = (nums[i-1] * nums[i-1]) % p; // Если степень не превышает степень в числе, то считаем
            i = i + 1; // счётчик +1
        } else {
            k = k + 1; // иначе выход из цикла
        }
    }

    int binary[100]; // инициализируем массив чисел, в котором хранится число в двоичной степени
    k = 0; // условие выхода
    i = 0; // счётчик
    while(k == 0) {
        binary[i] = x % 2; // считаем первый множитель в формуле
        x = x / 2;
        if (x == 1) {
            k = k + 1;
            binary[i+1] = x;
        }
        i = i + 1;
    }

    int result = 1;
    for (int j = 0; j <= i; j++) {
        result = result * pow(nums[j], binary[j]); // перемножаем множители между собой
    }
    result = result % p; // получаем остаток, деля число из формулы на модуль

    return result;
}

int main(){
    setlocale(LC_ALL, "Rus");

    cout << "Нахождение остатка числа a^x mod p:" << endl;
    
    int a, x, p; // ввод чисел
    cout << "Введите числа a, x и p: ";
    cin >> a >> x >> p;

    if (CheckPrime(p)==false) { // проверка, является ли модуль простым числом
        cout << "p не простое число." << endl;
        return 1;
    }

    if (a % p == 0 && x != 0) { // проверка, выполняется ли теорема Ферма
        cout << "Теорема Ферма не выполняется: a^x ≡ 0 (mod p)" << endl;
        return 1;
    }

    int result1 = algorithm1(a, x, p); // вывод результата
    cout << "Алгоритм 1: " << a << "^" << x << " mod " << p << " = " << result1 << endl;
    int result2 = algorithm2(a, x, p);
    cout << "Алгоритм 2: " << a << "^" << x << " mod " << p << " = " << result2 << endl;

    return 0;
}